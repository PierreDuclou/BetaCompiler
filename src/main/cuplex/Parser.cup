/**
 * Analyseur lexical
 *
 * Auteurs :
 *      Jérémy Thomas,
 *      Ouafa Bourekhsas,
 *      Salme Ould Ahmed,
 *      Théo Cominolo,
 *      Pierre Duclou
 *
 * Version SNAPSHOT-1.0
 */


/*
|------------------------------------------------------------------------------
| Header
|------------------------------------------------------------------------------
| This section includes the namespace declaration and all packages imports
|
*/

package generated.cuplex;

import ul.miage.l3.compilation.groupe_i.symbols.*;
import ul.miage.l3.compilation.groupe_i.ast.*;
import java.util.LinkedList;
import java.util.Arrays;


/*
|------------------------------------------------------------------------------
| Action code
|------------------------------------------------------------------------------
| Pure Java code (executed before the parsing)
|
*/

action code {:
    Integer context = null;
    boolean isParameter;
    SymbolsTable table = SymbolsTable.getInstance();
    AbstractSyntaxTree tree = AbstractSyntaxTree.getInstance();

    /**
     * Determine if a variable is global or local, then add it into the symbol table
     *
     * @param id id of the variable
     * @param type type of the variable
     * @param value value of the variable
     */
    private int addVariable(String id, String type, int value) {
        int key;

        if (context == null) {
            key = table.add(new GlobalVariable(id, type, value));
        } else {
            Function f = (Function) table.get(context);
            int rank = (f.getNumberOfLocalVariables() + 2) * 4;
            key = table.add(new LocalVariable(id, type, rank, context, value));
            f.incrementNumberOfLocalVariables();
        }

        return key;
    }

    /**
     * Add a parameter into the symbol table
     *
     * @param id id of the variable
     * @param type type of the variable
     */
    private int addParameter(String id, String type) {
        Function f = (Function) table.get(context);
        int rank = (f.getNumberOfParameters() - 2) * 4;
        int key = table.add(new Parameter(id, type, rank, context));
        f.incrementNumberOfParameters();

        return key;
    }
:};


/*
|------------------------------------------------------------------------------
| Gramar declaration
|------------------------------------------------------------------------------
| This section includes all terminals and non terminals declaration of the gramar
|
*/

// Verbose tokens
terminal INT, VOID, RETURN, IF, ELSE, WHILE;

// Delimiters
terminal SEMICOLON, COMMA, ARROW;

// Operators
terminal ADD, SUB, DIV, MUL, MOD, ASSIGN, LT, GT, GE, LE, EQ, DIFF;

// Wrappers
terminal OPEN_P, CLOSE_P, OPEN_B, CLOSE_B;

// Custom tokens
terminal ID, VALUE;

// Non terminals
non terminal entry;
non terminal LinkedList<Node> program;
non terminal InnerNode func_definition;
non terminal func_type;
non terminal parameters;
non terminal InnerNode func_call;
non terminal LinkedList<Node> arguments;
non terminal LinkedList<Node> block;
non terminal LinkedList<Node> inner_block;
non terminal control_flow;
non terminal if_statement;
non terminal condition;
non terminal comparison;
non terminal while_loop;
non terminal InnerNode instruction;
non terminal InnerNode concrete_instruction;
non terminal Node expression;
non terminal Node term;
non terminal Node factor;
non terminal InnerNode return_statement;
non terminal InnerNode var_declaration;
non terminal InnerNode var_assignation;


/*
|------------------------------------------------------------------------------
| Productions
|------------------------------------------------------------------------------
| This section includes all productions of the gramar
|
*/

start with entry;

entry ::= program:p
        {:
            InnerNode root = new InnerNode(NodeSymbol.PROGRAM, -1);
            root.addChild(p);
            tree.setRoot(root);
        :};

program ::= program var_declaration SEMICOLON {: RESULT = new LinkedList(); :}
          | program var_assignation SEMICOLON {: RESULT = new LinkedList(); :}
          | program:p func_definition:f {: p.add(f); RESULT = p; :}
          | {: RESULT = new LinkedList(); :};
          
//--- Function ----------------------------------------------------------------
func_definition ::= ID:id {: context = table.add(new Function((String) id)); :}
                    OPEN_P {: isParameter = true; :} parameters {: isParameter = false; :} 
                    CLOSE_P ARROW func_type:t block:b
                    {:
                        Function f = (Function) table.get(context);
                        f.setType((String) t);
                        RESULT = new InnerNode(NodeSymbol.FUNCTION, context, b);
                        context = null;
                    :};

func_type       ::= INT:i {: RESULT = i; :} | VOID:v {: RESULT = v; :};
parameters      ::= parameters COMMA var_declaration
                  | var_declaration
                  | ;
func_call       ::= ID:id OPEN_P arguments:a CLOSE_P {: RESULT = new InnerNode(NodeSymbol.CALL, -3, a); :};
arguments       ::= arguments:a COMMA expression:ex {: a.add(ex); :}
                  | expression:e {: RESULT = new LinkedList(Arrays.asList(new Node[] {e})); :}
                  | {: RESULT = new LinkedList(); :};

//--- Block -------------------------------------------------------------------
block       ::= OPEN_B block inner_block CLOSE_B
              | OPEN_B inner_block:i CLOSE_B {: RESULT = i; :};
inner_block ::= inner_block:in instruction:i
                {:
                    if (in != null) {
                        in.add(i);
                        RESULT = in;
                    } else {
                        RESULT = new LinkedList();
                    }
                :}
              | inner_block control_flow {: RESULT = new LinkedList(); :}
              | {: RESULT = new LinkedList(); :};

//--- Control flow ------------------------------------------------------------
control_flow ::= if_statement | while_loop;

// IF statement
if_statement ::= IF condition block
               | IF condition block ELSE block;

condition    ::= OPEN_P comparison CLOSE_P;
comparison   ::= expression LT expression
               | expression LE expression
               | expression EQ expression
               | expression DIFF expression
               | expression GE expression
               | expression GT expression;

// While loop
while_loop ::= WHILE condition block {::};

//--- Instruction -------------------------------------------------------------
instruction          ::= concrete_instruction:c SEMICOLON {: RESULT = c; :};
concrete_instruction ::= var_declaration:vd {: RESULT = vd; :}
                       | var_assignation:va {: RESULT = va; :}
                       | return_statement:r {: RESULT = r; :}
                       | func_call:f {: RESULT = f; :};

// Variable declaration
var_declaration ::= INT:t ID:id ASSIGN expression:e
                    {:
                        // Resolving key
                        int key;

                        if (e instanceof LeafNode) {
                            LeafNode tmp = (LeafNode) e;
                            key = addVariable(id.toString(), t.toString(), tmp.getValue());
                        } else {
                            key = addVariable(id.toString(), t.toString(), 0);
                        }

                        // If the variable is local
                        if (context != null) {
                            RESULT = new InnerNode(NodeSymbol.ASSIGN);
                            LeafNode left = new LeafNode(NodeSymbol.VARIABLE, key);
                            RESULT.addChild(left);
                            RESULT.addChild(e);
                        }
                    :}
                  | INT:t ID:id
                    {:
                        if (context != null)
                            addParameter(id.toString(), t.toString());
                        else
                            addVariable(id.toString(), t.toString(), 0);
                    :};

// Variable assignation
var_assignation  ::= ID:id ASSIGN expression:e
                    {:
                        RESULT = new InnerNode(NodeSymbol.ASSIGN);
                        RESULT.addChild(new LeafNode(NodeSymbol.VARIABLE, table.getClosestVariableKey(id.toString(), context)));
                        RESULT.addChild(e);
                    :};

// Return statement
return_statement ::= RETURN expression:e 
                    {:
                        InnerNode tmp = new InnerNode(NodeSymbol.RETURN, -4);
                        tmp.addChild(e);
                        RESULT = tmp;
                    :};

// Expression
expression ::= term ADD expression
             | term SUB expression
             | term:t {: RESULT = t; :};
term       ::= factor MUL term
             | factor DIV term
             | factor MOD term
             | factor:f {: RESULT = f; :};
factor     ::= OPEN_P expression CLOSE_P
             | func_call:f {: RESULT = f; :}
             | VALUE:v {: RESULT = new LeafNode(NodeSymbol.CONST, -2, v.toString()); :}
             | ID:id {: RESULT = new LeafNode(NodeSymbol.VARIABLE, table.getClosestVariableKey(id.toString(), context)); :};
