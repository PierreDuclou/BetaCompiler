/**
 * Analyseur lexical
 *
 * Auteurs :
 *      Jérémy Thomas,
 *      Ouafa Bourekhsas,
 *      Salme Ould Ahmed,
 *      Théo Cominolo,
 *      Pierre Duclou
 *
 * Version SNAPSHOT-1.0
 */


/*
|------------------------------------------------------------------------------
| Header
|------------------------------------------------------------------------------
| This section includes the namespace declaration and all packages imports
|
*/

package generated.cuplex;

import ul.miage.l3.compilation.groupe_i.symbols.*;
import ul.miage.l3.compilation.groupe_i.ast.*;


/*
|------------------------------------------------------------------------------
| Action code
|------------------------------------------------------------------------------
| Pure Java code (executed before the parsing)
|
*/

action code {:
    Integer context = null;
    SymbolsTable table = SymbolsTable.getInstance();
    AbstractSyntaxTree tree = AbstractSyntaxTree.getInstance();

    /**
     * Determine if a variable is global or local, then add it into the symbol table
     *
     * @param data attributes of the variable
     */
    private void addVariable(String[] data) {
        System.out.println(data[0]);
        if (context == null) {
            table.add(new GlobalVariable(data[0], data[1], data[2]));
        } else {
            Function f = (Function) table.get(context);
            int rank = (f.getNumberOfLocalVariables() + 2) * 4;
            table.add(new LocalVariable(data[0], data[1], rank, context, data[2]));
            f.incrementNumberOfLocalVariables();
        }
    }

    /**
     * Add a parameter into the symbol table
     *
     * @param data attributes of the variable
     */
    private void addParameter(String[] data) {
        Function f = (Function) table.get(context);
        int rank = (f.getNumberOfParameters() - 2) * 4;
        table.add(new Parameter(data[0], data[1], rank, context));
        f.incrementNumberOfParameters();
    }
:};


/*
|------------------------------------------------------------------------------
| Gramar declaration
|------------------------------------------------------------------------------
| This section includes all terminals and non terminals declaration of the gramar
|
*/

// Verbose tokens
terminal INT, VOID, RETURN, IF, ELSE, WHILE;

// Delimiters
terminal SEMICOLON, COMMA, ARROW;

// Operators
terminal ADD, SUB, DIV, MUL, MOD, ASSIGN, LT, GT, GE, LE, EQ;

// Wrappers
terminal OPEN_P, CLOSE_P, OPEN_B, CLOSE_B;

// Custom tokens
terminal ID, VALUE;

// Non terminals
non terminal entry;
non terminal program;
non terminal func_definition;
non terminal func_type;
non terminal parameters;
non terminal func_call;
non terminal arguments;
non terminal block;
non terminal inner_block;
non terminal control_flow;
non terminal if_statement;
non terminal condition;
non terminal comparison;
non terminal while_loop;
non terminal instruction;
non terminal concrete_instruction;
non terminal expression;
non terminal term;
non terminal factor;
non terminal return_statement;
non terminal String[] var_declaration;
non terminal String[] var_assignation;


/*
|------------------------------------------------------------------------------
| Productions
|------------------------------------------------------------------------------
| This section includes all productions of the gramar
|
*/

start with entry;

entry ::= program;

program ::= program var_declaration SEMICOLON
          | var_declaration:v SEMICOLON {: addVariable(v); :}
          | program var_assignation SEMICOLON
          | var_assignation:va SEMICOLON {: addVariable(va); :}
          | program func_definition
          | func_definition;

//--- Function ----------------------------------------------------------------
func_definition ::= ID:id {: context = table.add(new Function((String) id)); :} OPEN_P parameters CLOSE_P ARROW func_type:t block
                    {:
                        Function f = (Function) table.get(context);
                        f.setType((String) t);
                        context = null;
                    :};

func_type       ::= INT:i {: RESULT = i; :} | VOID:v {: RESULT = v; :};
parameters      ::= parameters COMMA var_declaration
                  | var_declaration:v {: addParameter(v); :}
                  | ;
func_call       ::= ID OPEN_P arguments CLOSE_P;
arguments       ::= arguments COMMA expression
                  | expression
                  | ;

//--- Block -------------------------------------------------------------------
block       ::= OPEN_B block inner_block CLOSE_B
              | OPEN_B inner_block CLOSE_B
              | OPEN_B CLOSE_B;
inner_block ::= inner_block instruction
              | instruction
              | inner_block control_flow
              | control_flow;

//--- Control flow ------------------------------------------------------------
control_flow ::= if_statement
               | while_loop;

// IF statement
if_statement ::= IF condition block
               | IF condition block ELSE block;

condition    ::= OPEN_P comparison CLOSE_P;
comparison   ::= expression LT expression
               | expression LE expression
               | expression EQ expression
               | expression GE expression
               | expression GT expression;

// While loop
while_loop ::= WHILE condition block;

//--- Instruction -------------------------------------------------------------
instruction          ::= concrete_instruction SEMICOLON;
concrete_instruction ::= var_declaration:v {: addVariable(v); :}
                       | var_assignation:va
                       | return_statement
                       | func_call
                       | ;

var_declaration ::= INT:t ID:id ASSIGN expression:e {: RESULT = new String[] { (String) id, (String) t, (String) e }; :}
                  | INT:t ID:id {: RESULT = new String[] { (String) id, (String) t, null }; :};

var_assignation  ::= ID ASSIGN expression;
return_statement ::= RETURN expression;

// Expression
expression ::= term ADD expression
             | term SUB expression
             | term:t {: RESULT = t; :};
term       ::= factor MUL term
             | factor DIV term
             | factor MOD term
             | factor:f {: RESULT = f; :};
factor     ::= OPEN_P expression CLOSE_P
             | func_call
             | VALUE:v {: RESULT = v; :}
             | ID:id {: RESULT = id; :};
